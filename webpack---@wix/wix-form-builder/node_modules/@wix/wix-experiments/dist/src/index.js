"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var tslib_1 = require("tslib");
var base_url_1 = require("./base-url");
var global_defaults_1 = require("./conduction-utils/global-defaults");
var global_defaults_checks_1 = require("./conduction-utils/global-defaults-checks");
var request_context_1 = require("./conduction-utils/request-context");
var experiments_cache_1 = require("./experiments-cache");
var experiments_data_utils_1 = require("./experiments-data-utils");
var http_request_1 = require("./http-request");
var urlMap_1 = require("./urlMap");
var noop = function() {
    /* */
};
var Experiments = /** @class */ (function() {
    function Experiments(obj) {
        if (obj === void 0) {
            obj = {};
        }
        var globalDefaults = global_defaults_1.getGlobalDefaults();
        this.useNewApi =
            typeof obj.useNewApi !== 'undefined' ?
            obj.useNewApi :
            globalDefaults.useNewApi || false;
        this.experiments = obj.experiments || {};
        this.loaders = new Map();
        this.baseUrl = base_url_1.baseUrl(this.useNewApi, obj.baseUrl);
        this.requestContext =
            obj.requestContext || global_defaults_checks_1.getGlobalRequestContext(globalDefaults);
        this.onError = obj.onError || noop;
        if (obj.scope) {
            this.load(obj.scope);
        }
    }
    Experiments.prototype.add = function(obj) {
        this.experiments = tslib_1.__assign(tslib_1.__assign({}, this.experiments), obj);
    };
    Experiments.prototype.get = function(key) {
        return this.experiments[key];
    };
    Experiments.prototype.enabled = function(key) {
        return this.get(key) === 'true';
    };
    Experiments.prototype.all = function() {
        return this.experiments;
    };
    Experiments.prototype._addLoader = function(url, promise) {
        var _this = this;
        this.loaders.set(url, promise);
        promise.then(function() {
            _this.loaders.delete(url);
        });
        return promise;
    };
    Experiments.prototype._getUrlWithFallback = function(url, fallback) {
        var _this = this;
        var cachedResponse = experiments_cache_1.getCacheInstance().getUrlResponse(url);
        if (cachedResponse !== undefined) {
            return Promise.resolve(cachedResponse);
        }
        var existingRequest = this.loaders.get(url);
        if (existingRequest !== undefined) {
            return existingRequest;
        }
        return http_request_1.httpRequest(url)
            .then(function(response) {
                experiments_cache_1.getCacheInstance().addUrlResponse(url, response);
                return response;
            })
            .catch(function(error) {
                _this.onError(error);
                return fallback;
            });
    };
    Experiments.prototype.load = function(scope) {
        var _this = this;
        var scopeConductionPath = urlMap_1.getAllInScopePath(scope, this.useNewApi);
        var requestContextQuery = this.useNewApi ?
            request_context_1.getRequestContextQuery(this.requestContext) :
            '';
        var url = "" + this.baseUrl + scopeConductionPath + requestContextQuery;
        var result = this._getUrlWithFallback(url, {})
            .then(experiments_data_utils_1.tryParse)
            .then(function(response) {
                return (_this.useNewApi ? response.values : response);
            })
            .then(function(obj) {
                return _this.add(obj);
            });
        return this._addLoader(url, result);
    };
    Experiments.prototype.conduct = function(spec, fallbackValue) {
        var _this = this;
        // check if a spec value was already loaded to the cache indirectly through another request
        var cachedResponse = experiments_cache_1.getCacheInstance().getExperimentValue(spec, this.useNewApi);
        if (cachedResponse !== undefined) {
            return this._addConductResult(spec, cachedResponse);
        }
        var experimentsPath = urlMap_1.getExperimentPath(spec, fallbackValue, this.useNewApi);
        var requestContextQuery = this.useNewApi ?
            request_context_1.getRequestContextQuery(this.requestContext) :
            '';
        var url = "" + this.baseUrl + experimentsPath + requestContextQuery;
        var result = this._getUrlWithFallback(url, fallbackValue)
            .then(function(response) {
                return _this._addConductResult(spec, response);
            });
        return this._addLoader(url, result);
    };
    Experiments.prototype.pending = function() {
        return !!this.loaders.size;
    };
    Experiments.prototype.ready = function() {
        return Promise.all(Array.from(this.loaders.values()));
    };
    Experiments.prototype._addConductResult = function(spec, conductResponse) {
        var _a;
        var value = this.useNewApi ? JSON.parse(conductResponse).value : conductResponse;
        this.add((_a = {}, _a[spec] = value, _a));
        return Promise.resolve(value);
    };
    return Experiments;
}());
exports.default = Experiments;
//# sourceMappingURL=index.js.map