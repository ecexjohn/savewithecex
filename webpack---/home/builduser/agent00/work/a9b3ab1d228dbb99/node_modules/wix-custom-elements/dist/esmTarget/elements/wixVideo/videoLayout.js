var _videoPositions;

import {
    joinURL,
    unique
} from '../../utils/utils';
import {
    setAttributes,
    setStyle
} from '../../utils/domUtils';
import imageClientApi from 'image-client-api/dist/imageClientApi';
export default {
    /**
     * @param {HTMLVideoElement} videoNode
     * @param {HTMLDivElement} container
     * @param {boolean} hasBgScrollEffect
     * @param {number} videoWidth
     * @param {number} videoHeight
     * @param {string} fittingType
     * @param {string} alignType
     * @param {Object[]} qualities
     * @param {string} staticVideoUrl
     * @param {string} videoId
     * @param {string} videoFormat
     * @return {{currentSrc: string, videoStyle: {top: number, left: number, width: number, height: number}, videoSourceUrl: string}}
     */
    measure: function measure(videoNode, container, hasBgScrollEffect, videoWidth, videoHeight, fittingType, alignType, qualities, staticVideoUrl, videoId, videoFormat) {
        // if background has a full-height scroll effect we use the parent width,
        // the element position is fixed and without explicit width it will take
        // the viewport's width or the width of an ancestor with a transform (i.e. page in transition)
        var width = hasBgScrollEffect ? container.offsetWidth : videoNode.parentElement.offsetWidth;
        var height = videoNode.parentElement.offsetHeight;
        var vidWidth = parseInt(videoWidth, 10);
        var vidHeight = parseInt(videoHeight, 10);
        var scaleFactor = getScaleFactor(width, height, vidWidth, vidHeight);
        var videoScaledDimensions = getVideoDimension(fittingType, scaleFactor, vidWidth, vidHeight);
        var videoPosition = getVideoPosition(alignType, videoScaledDimensions, {
            width: width,
            height: height
        });
        var targetQuality = getVideoQualityBySize(qualities, videoScaledDimensions);
        var videoSourceUrl = getMP4Url(targetQuality, staticVideoUrl, videoId, videoFormat);
        var needsSrcUpdate = shouldUpdateSrc(videoNode, videoSourceUrl);
        return {
            videoSourceUrl: videoSourceUrl,
            needsSrcUpdate: needsSrcUpdate,
            videoStyle: {
                width: videoScaledDimensions.width,
                height: videoScaledDimensions.height,
                left: videoPosition.left,
                top: videoPosition.top
            }
        };
    },

    /**
     * @param {HTMLDivElement} poster
     * @param {HTMLCanvasElement|null} canvas
     * @param {HTMLVideoElement} videoNode
     * @param {Object} videoStyle
     * @param {boolean} autoPlay
     * @param {string} videoSourceUrl
     * @param {boolean} needsSrcUpdate
     * @param {string} animatePoster
     * @param {string} videoFormat
     * @param {number} playbackRate
     * @param {boolean} isEditorMode
     */
    mutate: function mutate(poster, canvas, hasThunderBoltCanvas, videoNode, videoStyle, autoPlay, videoSourceUrl, needsSrcUpdate, animatePoster, videoFormat, playbackRate, isEditorMode) {
        setAttributes(videoNode, {
            width: videoStyle.width,
            height: videoStyle.height
        });
        var notCanvas = !hasThunderBoltCanvas && !canvas;

        if (notCanvas) {
            handlePosterVisibility(needsSrcUpdate, videoNode, poster, animatePoster, autoPlay, isEditorMode);

            if (autoPlay) {
                videoNode.setAttribute('autoplay', '');
            } else {
                videoNode.removeAttribute('autoplay');
            }

            setStyle(videoNode, videoStyle);
        } else if (canvas) {
            setStyle(canvas, videoStyle);
        }

        patchVideoSource(needsSrcUpdate, videoNode, videoSourceUrl);
        videoNode.playbackRate = playbackRate;
    }
};
var alignTypes = imageClientApi.alignTypes;
var videoPositions = (_videoPositions = {}, _videoPositions[alignTypes.CENTER] = function(positionOptions) {
    return {
        left: positionOptions.horizontalMiddle,
        top: positionOptions.verticalMiddle
    };
}, _videoPositions[alignTypes.LEFT] = function(positionOptions) {
    return {
        left: 0,
        top: positionOptions.verticalMiddle
    };
}, _videoPositions[alignTypes.RIGHT] = function(positionOptions) {
    return {
        left: positionOptions.left,
        top: positionOptions.verticalMiddle
    };
}, _videoPositions[alignTypes.TOP] = function(positionOptions) {
    return {
        left: positionOptions.horizontalMiddle,
        top: 0
    };
}, _videoPositions[alignTypes.BOTTOM] = function(positionOptions) {
    return {
        left: positionOptions.horizontalMiddle,
        top: positionOptions.top
    };
}, _videoPositions[alignTypes.TOP_LEFT] = function() {
    return {
        left: 0,
        top: 0
    };
}, _videoPositions[alignTypes.TOP_RIGHT] = function(positionOptions) {
    return {
        left: positionOptions.left,
        top: 0
    };
}, _videoPositions[alignTypes.BOTTOM_LEFT] = function(positionOptions) {
    return {
        left: 0,
        top: positionOptions.top
    };
}, _videoPositions[alignTypes.BOTTOM_RIGHT] = function(positionOptions) {
    return {
        left: positionOptions.left,
        top: positionOptions.top
    };
}, _videoPositions);
/**
 *
 * @param videoNode
 * @param newSrcUrl
 * @returns {*|boolean}
 */

function shouldUpdateSrc(videoNode, newSrcUrl) {
    var hasError = videoNode.networkState === videoNode.NETWORK_NO_SOURCE;
    var hasDiff = !videoNode.currentSrc.endsWith(newSrcUrl);
    return newSrcUrl && (hasDiff || hasError);
}
/**
 * Calculate width and height of video's
 * visible rect according to provided `fittingType`.
 *
 * @param {string} fittingType
 * @param {{wScale: number, hScale: number}} videoScale
 * @param {number} videoWidth
 * @param {number} videoHeight
 * @return {{width: number, height: number}}
 */


function getVideoDimension(fittingType, videoScale, videoWidth, videoHeight) {
    var scale;

    if (fittingType === imageClientApi.fittingTypes.SCALE_TO_FIT) {
        scale = Math.min(videoScale.wScale, videoScale.hScale);
    } else {
        // default: imageClientApi.fittingTypes.SCALE_TO_FILL
        scale = Math.max(videoScale.wScale, videoScale.hScale);
    }

    return {
        width: Math.round(videoWidth * scale),
        height: Math.round(videoHeight * scale)
    };
}
/**
 * Calculate ratio between video's width and height, and its container's.
 *
 * @param {number} containerWidth
 * @param {number} containerHeight
 * @param {number} videoWidth
 * @param {number} videoHeight
 * @return {{wScale: number, hScale: number}}
 */


function getScaleFactor(containerWidth, containerHeight, videoWidth, videoHeight) {
    return {
        wScale: containerWidth / videoWidth,
        hScale: containerHeight / videoHeight
    };
}
/**
 * @param {string} alignType
 * @param {{width: number, height: number}} videoDimensions
 * @param {{width: number, height: number}} videoContainerDimensions
 * @return {{left: number, top: number}}
 */


function getVideoPosition(alignType, videoDimensions, videoContainerDimensions) {
    var containerWidth = videoContainerDimensions.width,
        containerHeight = videoContainerDimensions.height;
    var videoWidth = videoDimensions.width,
        videoHeight = videoDimensions.height;
    var widthDelta = containerWidth - videoWidth;
    var heightDelta = containerHeight - videoHeight;
    return videoPositions[alignType || imageClientApi.alignTypes.CENTER]({
        verticalMiddle: Math.round(heightDelta / 2),
        horizontalMiddle: Math.round(widthDelta / 2),
        top: heightDelta,
        left: widthDelta
    });
}
/**
 * Pick the desired video quality from a list of given qualities
 * according to visible rect dimensions.
 *
 * @param {Object[]} qualities
 * @param {{width: number, height: number}} videoScaledDimensions
 * @return {Object} the quality to use
 */


function getVideoQualityBySize(qualities, _ref) {
    var width = _ref.width,
        height = _ref.height;
    var uniqueQualities = unique(qualities, function(item) {
        return item.size;
    });
    var targetQuality = uniqueQualities.find(function(value) {
        return value.size > width * height;
    });
    return targetQuality || qualities[qualities.length - 1];
}
/**
 * Get a full URL for the video if playing MP4 format, or empty string otherwise.
 *
 * @param {Object} targetQuality
 * @param {string} staticVideoUrl
 * @param {string} videoId
 * @param {string} videoFormat
 * @returns {string}
 */


function getMP4Url(targetQuality, staticVideoUrl, videoId, videoFormat) {
    if (videoFormat === 'mp4') {
        // prefer video URL from new design data structure
        if (targetQuality.url) {
            return joinURL(staticVideoUrl, targetQuality.url);
        } // build URL from videoId


        return joinURL(staticVideoUrl, videoId, targetQuality.quality, videoFormat, 'file.mp4');
    }

    return '';
}
/**
 *
 * @param {boolean} needsEventUpdate
 * @param {HTMLVideoElement} videoNode
 * @param {HTMLDivElement} posterNode
 * @param {string} animatePoster
 * @param {boolean} autoplay
 * @param {boolean} isEditorMode
 */


function handlePosterVisibility(needsEventUpdate, videoNode, posterNode, animatePoster, autoplay, isEditorMode) {
    //todo: (preview -> Editor case) move to editor layout hooks
    //bring back the poster (preview -> Editor case)
    if (isEditorMode && videoNode.paused) {
        posterNode.style.opacity = '1';
        videoNode.style.opacity = '0';
    } //todo: (preview -> Editor case) move to editor layout hooks
    //register to events when updating src or when in Editor(preview -> Editor case)


    var needsEventUpdateWithEditor = videoNode.paused && (needsEventUpdate || isEditorMode);

    if (needsEventUpdateWithEditor) {
        videoNode.ontimeupdate = null;
        videoNode.onseeked = null;
        videoNode.onplay = null;

        if (!isEditorMode && autoplay) {
            //sync the poster removal with video first frame
            videoNode.ontimeupdate = function() {
                if (videoNode.currentTime > 0) {
                    videoNode.ontimeupdate = null;

                    videoNode.onseeked = function() {
                        videoNode.onseeked = null;
                        removePoster(videoNode, posterNode, animatePoster);
                    };

                    videoNode.currentTime = 0;
                }
            };
        } else {
            videoNode.onplay = function() {
                videoNode.onplay = null;
                removePoster(videoNode, posterNode, animatePoster);
            };
        }
    }
}
/**
 * Load the video if needed.
 *
 * @param {boolean} needsSrcUpdate
 * @param {HTMLVideoElement} videoNode
 * @param {string} newSrc
 */


function patchVideoSource(needsSrcUpdate, videoNode, newSrc) {
    if (needsSrcUpdate) {
        videoNode.src = newSrc;
        videoNode.load();
    }
}
/**
 * Show video , hide poster
 *
 * @param videoNode
 * @param posterNode
 * @param animatePoster
 */


function removePoster(videoNode, posterNode, animatePoster) {
    if (animatePoster === 'fade') {
        posterNode.style.transition = 'opacity 1.6s ease-out';
    }

    posterNode.style.opacity = '0';
    videoNode.style.opacity = '1';
}
//# sourceMappingURL=videoLayout.js.map