'use strict';

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var assert = require('./assert');

var _require = require('./utils/collections'),
    mapValues = _require.mapValues,
    filterValues = _require.filterValues;

var promise = require('./utils/promise');
var log = require('./utils/log');
var EventBuffer = require('./utils/event-buffer');

var BiLogger = function() {
    //TODO: validate args
    function BiLogger(options, context) {
        _classCallCheck(this, BiLogger);

        this._publishers = options.publishers;
        this._validators = options.validators || [];
        this._defaults = options.defaults;
        this._events = options.events || {};
        this._context = context || {};
        this._defaultValueTimeout = options.defaultValueTimeout || 5000;
        this._defaultContinueOnFail = options.defaultContinueOnFail || false;
        this._onPublisherFailHandler = options.onPublisherFailHandler || BiLogger._defaultPublisherFailHandler;
    }

    _createClass(BiLogger, [{
        key: 'log',
        value: function log(eventOrKey, eventOrContextOrUndefined, contextOrUndefined) {
            var _this = this;

            assert.defined(eventOrKey, 'Event object or event key must be provided.');

            var _extractEventAndConte = this._extractEventAndContext(eventOrKey, eventOrContextOrUndefined, contextOrUndefined),
                event = _extractEventAndConte.event,
                context = _extractEventAndConte.context;

            var useBatch = typeof context.useBatch !== 'undefined' ? context.useBatch : this._context.useBatch;

            if (useBatch) {
                var buffer = this._initBuffer(useBatch);

                var dynamicDefaults = filterValues(this._defaults, function(v) {
                    return typeof v === 'function';
                });
                var resolvedDefaults = mapValues(dynamicDefaults, function(v) {
                    return v();
                });

                return buffer.feed(Object.assign({}, event, resolvedDefaults), context);
            }

            return this._getDefaults().then(function(defaults) {
                var fullEvent = Object.assign({}, defaults, event);

                var validatorsResult = _this._validators.length === 0 ? true : _this._validators.some(function(validator) {
                    return validator.match(fullEvent) && (validator.execute(fullEvent) || true);
                });

                if (!validatorsResult) {
                    throw new Error('No validator accepted the event. Source: ' + fullEvent.src + ' Evid: ' + (fullEvent.evid || fullEvent.evtId));
                }

                return _this._send(fullEvent, context);
            });
        }
    }, {
        key: 'flush',
        value: function flush() {
            if (!this._buffer) {
                return Promise.resolve();
            }
            return this._buffer.flush();
        }
    }, {
        key: '_send',
        value: function _send(payload) {
            var _this2 = this;

            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            return Promise.all(this._publishers.map(function(publisher) {
                var cloned = Object.assign({}, payload);

                return Promise.resolve().then(function() {
                    return publisher(cloned, Object.assign({}, _this2._context, context));
                }).catch(function(error) {
                    return _this2._onPublisherFailHandler(error, {
                        publisherName: publisher.name
                    });
                });
            })).then(function() {
                return undefined;
            });
        }
    }, {
        key: '_extractEventAndContext',
        value: function _extractEventAndContext(eventOrKey, eventOrContextOrUndefined, contextOrUndefined) {
            var event = void 0;
            var context = {};

            if (typeof eventOrKey !== 'string') {
                event = eventOrKey;
                context = eventOrContextOrUndefined || context;
            } else {
                event = this._events[eventOrKey];

                if (!event) {
                    throw new assert.AssertionError('Event with key \'' + eventOrKey + '\' not found in event map.');
                }

                if (eventOrContextOrUndefined) {
                    event = Object.assign({}, event, eventOrContextOrUndefined);
                    context = contextOrUndefined || context;
                }
            }

            return {
                event: event,
                context: context
            };
        }
    }, {
        key: '_initBuffer',
        value: function _initBuffer(useBatch) {
            var _this3 = this;

            var debounceMs = useBatch === true ? 300 : useBatch;

            return this._buffer || (this._buffer = new EventBuffer(debounceMs).onFlush(function(batchPayload) {
                var staticDefaults = filterValues(_this3._defaults, function(v) {
                    return typeof v !== 'function';
                });
                batchPayload.g = staticDefaults;

                return _this3._send(batchPayload, {
                    useBatch: useBatch
                });
            }));
        }
    }, {
        key: '_handleDefaultsError',
        value: function _handleDefaultsError(err) {
            if (this._defaultContinueOnFail) {
                log.error(err);
                return null;
            }
            return Promise.reject(err);
        }
    }, {
        key: '_getDefaults',
        value: function _getDefaults() {
            var _this4 = this;

            if (!this._defaults) {
                return Promise.resolve({});
            }

            var promises = mapValues(this._defaults, function(value, key) {
                if (typeof value === 'function') {
                    try {
                        value = value();
                    } catch (err) {
                        return _this4._handleDefaultsError(err);
                    }
                }
                if (value && typeof value.then !== 'function') {
                    return value;
                }
                return promise.timedPromise(value, {
                    message: 'Cannot get default value \'' + key + ' for BI Event\'',
                    timeout: _this4._defaultValueTimeout
                }).catch(function(err) {
                    return _this4._handleDefaultsError(err);
                });
            });

            return promise.allAsObject(promises);
        }
    }], [{
        key: '_defaultPublisherFailHandler',
        value: function _defaultPublisherFailHandler(error, _ref) {
            var publisherName = _ref.publisherName;

            return publisherName; // do nothing
        }
    }]);

    return BiLogger;
}();

module.exports = BiLogger;
//# sourceMappingURL=bi-logger.js.map